@base         <urn:pipeline:xrm> .
@prefix :     <https://pipeline.described.at/> .
@prefix code: <https://code.described.at/> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

_:variablesObservation :variable
    [ a :Variable; :name "mappingsDir"; :value "observation/*.json" ] ,
    [ a :Variable; :name "inputDir"; :value "input" ] ,
    [ a :Variable; :name "targetFile"; :value "output/transformed.nt" ]
.

_:variablesDefault :variable
    [ a :Variable; :name "mappingsDir"; :value "src-gen/*.json" ] ,
    [ a :Variable; :name "inputDir"; :value "input" ] ,
    [ a :Variable; :name "targetFile"; :value "output/transformed.nt" ]
.


<#MainFile> a :Pipeline ;
    :steps [ :stepList ( <#mergeInputs> <#streamOutputStep> ) ] ;
    :variables _:variablesDefault .

<#MainFileObservation> a :Pipeline ;
    :steps [ :stepList ( <#mergeInputs> <#streamOutputStep> ) ] ;
    :variables _:variablesObservation .

#<#MainStoreHdb>
<#MainStore> a :Pipeline ;
    :steps [ :stepList ( <#mergeInputs> <#setGraph> <#upload> ) ] .

<#mergeInputs> a :Step ;
    code:implementedBy [ a code:EcmaScript ;
      code:link <node:barnard59-base#concat.object> ] ;
    code:arguments     ( <#TransformFiles> ) .

<#streamOutputStep> a :Step ;
    code:implementedBy [ a code:EcmaScript ;
      code:link <file:../lib/pipeline#asStep> ] ;
    code:arguments     ( <#StreamOutputFile> ) .

<#StreamOutputFile> a :Pipeline, :WritableObjectMode ;
    :steps     [ :stepList ( <#serialize> <#save> ) ] .

<#serialize> a :Step ;
    code:implementedBy [  a code:EcmaScript ;
      code:link <node:barnard59-formats#ntriples.serialize> ] .

<#save> a :Step ;
    code:implementedBy [ a code:EcmaScript ; 
      code:link <node:fs#createWriteStream> ] ;
    code:arguments     ( "targetFile"^^:VariableName ) .

<#StreamOutputStore> # TODO should be a step?
    :steps     [ :stepList ( <#setGraph> <#upload> ) ] .

# ------------------------------
#
# Transform pipeline
#
# One-by-one parses and transforms the source csv files to RDF
#
# ------------------------------

<#TransformFiles> a :Pipeline, :ReadableObjectMode ;
    :steps [ :stepList ( <#loadMappings> <#doTransform> ) ] .

<#loadMappings> a :Step ;
    code:implementedBy [ a code:EcmaScript ;
      code:link <node:barnard59-base#glob> ] ;
    code:arguments     [ code:name  "pattern" ;
                         code:value "mappingsDir"^^:VariableName ] .

<#doTransform> a :Step ;
    code:implementedBy [ a code:EcmaScript ;
      code:link <node:barnard59-core#forEach> ] ;
    code:arguments     ( <#TransformCsv>
                         "(p, fileName) => { p.variables.set('csvw', fileName) }"^^code:EcmaScript ) .

# ------------------------------
#
# Transforms individual files
#
# ------------------------------


#<#TransformCsv>
#    a      :Pipeline, :ReadableObjectMode ;
#    :steps [ :stepList ( <#loadCsvStep> <#parse> ) ] .


#<#TransformCsvObservation>
<#TransformCsv>

    a      :Pipeline, :ReadableObjectMode ;
    :steps [
      :stepList (
        <#loadCsvStep>
        <#parse>
        <#mapAll>
        <#filterAll>
        <#toDataset>
        <#toObservation>
        <#toCubeShape>
        <#flatten>
      )
    ] .

<#LoadCsv>
    a      :Pipeline, :ReadableObjectMode ;
    :steps [ :stepList ( <#openCsvFromFilesystem> ) ] .

<#openCsvFromFilesystem>
    a                  :Step ;
    code:implementedBy [ code:link <file:../lib/csv#openFromCsvw> ;
                         a         code:EcmaScript ] ;
    code:arguments     ( "${csvw}"^^code:EcmaScriptTemplateLiteral ) .


<#loadCsvStep> a :Step ;
    code:implementedBy [ a code:EcmaScript ;
      code:link <file:../lib/pipeline#asStep>  ] ;
    code:arguments     ( <#LoadCsv> ) .

<#parse> a :Step ;
    code:implementedBy [ a code:EcmaScript ;
      code:link <node:barnard59-formats#csvw.parse> ] ;
    code:arguments     ( <#parseMetadata> ) .

<#parseMetadata> a :Pipeline, :ReadableObjectMode ;
    :steps [ :stepList ( <#readMetadata> <#parseMetadataStep> ) ] .

<#parseMetadataStep> a :Step ;
    code:implementedBy [ a code:EcmaScript ;
      code:link <node:barnard59-formats#jsonld.parse> ] .

<#readMetadata> a :Step ;
    code:implementedBy [ a code:EcmaScript ; 
      code:link <node:fs#createReadStream> ] ;
    code:arguments     ( "${csvw}"^^code:EcmaScriptTemplateLiteral ) .

<#filterAll> a :Step ;
    code:implementedBy [ a code:EcmaScript ;
                         code:link <node:barnard59-base#filter> ] ;
    code:arguments     ( [ a code:EcmaScript;
     code:link <file:../lib/steps-filter#all> ] ) .

<#mapAll> a :Step;
  code:implementedBy [ a code:EcmaScript;
    code:link <node:barnard59-base#map>
 ];
 code:arguments ( [ a code:EcmaScript ;
                    code:link <file:../lib/steps-map#all>
                  ] ).

<#toDataset> a :Step;
  code:implementedBy [ a code:EcmaScript;
    code:link <node:rdf-stream-to-dataset-stream/bySubject.js>
  ].

<#toObservation> a :Step;
  code:implementedBy [ a code:EcmaScript;
    code:link <node:barnard59-rdf/cube.js#toObservation>
  ];
  code:arguments [
    code:name "observer";
    code:value "https://ld.stadt-zuerich.ch/"
  ], [
    code:name "observations";
    code:value """({ dataset }) => {
      const rdf = require('rdf-ext')
      const quad = [...dataset][0]
      const parts = quad.subject.value.split('/')
      const baseIri = parts.slice(0, -3).join('/')
      const cubeId = parts.slice(-3, -2)[0].split('-').filter(s => s !== 'XXX').join('-')
      const observationsPath = parts.slice(-2)[0]
      const observationsIri = [baseIri, cubeId, observationsPath].join('/') + '/'

      return rdf.namedNode(observationsIri)
    }"""^^code:EcmaScript
  ], [
    code:name "observation";
    code:value """({ dataset, observations }) => {
      const rdf = require('rdf-ext')
      const quad = [...dataset][0]
      const parts = quad.subject.value.split('/')
      const groupId = parts.slice(-1)[0].split('-').slice(0, -2).filter(s => s !== 'XXX0000').join('-')
      const raumZeitId = parts.slice(-1)[0].split('-').slice(-2).join('-')
      const observationId = [groupId, raumZeitId].filter(Boolean).join('-')

      const observationIri = observations.value + observationId

      return rdf.namedNode(observationIri)
    }"""^^code:EcmaScript
  ].

<#toCubeShape> a :Step;
  code:implementedBy [ a code:EcmaScript;
    code:link <file:../lib/toCubeShape>
  ];
  code:arguments [
    code:name "excludeValuesOf";
    code:value (
      "http://www.w3.org/2004/02/skos/core#notation"
      "https://ld.stadt-zuerich.ch/statistics/attribute/BEZUGSZEIT"
      "https://ld.stadt-zuerich.ch/statistics/attribute/ERWARTETE_AKTUALISIERUNG"
    )
  ].

<#flatten> a :Step;
  code:implementedBy [ a code:EcmaScript;
    code:link <node:barnard59-base#flatten>;
  ].

<#setGraph> a :Step;
  code:implementedBy [ a code:EcmaScript;
    code:link <node:barnard59-base#setGraph>
  ];
  code:arguments ( "graph"^^:VariableName ).

<#upload> a :Step;
  code:implementedBy [ a code:EcmaScript;
    code:link <node:barnard59-graph-store#put>
  ];
  code:arguments [
    code:name "endpoint";
    code:value "endpoint"^^:VariableName
  ], [
    code:name "user";
    code:value "user"^^:VariableName
  ], [
    code:name "password";
    code:value "password"^^:VariableName
  ].